package com.br.b12clans.managers;

import com.br.b12clans.Main;
import com.br.b12clans.models.Clan;
import com.br.b12clans.utils.SmallTextConverter;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

public class ClanManager {

    private final Main plugin;
    private final Map<UUID, Clan> playerClans;
    private final Map<UUID, Integer> pendingInvites;

    private static final Pattern HEX_PATTERN = Pattern.compile("&#[a-fA-F0-9]{6}");
    private static final Pattern NAME_PATTERN = Pattern.compile("^[a-zA-Z0-9_]{2,32}$");
    private static final Pattern TAG_CLEAN_PATTERN = Pattern.compile("^[a-zA-Z0-9\\[\\]\\(\\)-_&]{1,16}$");

    public ClanManager(Main plugin) {
        this.plugin = plugin;
        this.playerClans = new ConcurrentHashMap<>();
        this.pendingInvites = new ConcurrentHashMap<>();
    }

    public void addInvite(UUID invitedPlayer, int clanId) {
        pendingInvites.put(invitedPlayer, clanId);
    }

    public Integer getPendingInvite(UUID invitedPlayer) {
        return pendingInvites.get(invitedPlayer);
    }

    public void removeInvite(UUID invitedPlayer) {
        pendingInvites.remove(invitedPlayer);
    }

    public CompletableFuture<Clan> getClanById(int clanId) {
        return CompletableFuture.supplyAsync(() ->
                plugin.getDatabaseManager().getClanById(clanId)
        );
    }

    public void broadcastToClan(int clanId, String message) {
        // TODO: Implementar a lógica de broadcast
    }

    public boolean isValidClanName(String name) {
        return name != null && NAME_PATTERN.matcher(name).matches();
    }

    public boolean isValidClanTag(String tag) {
        if (tag == null || tag.trim().isEmpty()) return false;

        // Remove cores para validar apenas o conteúdo
        String cleanTag = ChatColor.stripColor(translateHexColors(tag));

        // Verificar se o conteúdo limpo está dentro dos limites mais flexíveis
        if (!TAG_CLEAN_PATTERN.matcher(cleanTag).matches()) {
            return false;
        }

        // Verificar se a tag expandida não é excessivamente longa (limite de 1000 caracteres)
        String expandedTag = translateColors(tag);
        return expandedTag.length() <= 1000;
    }

    public String translateHexColors(String message) {
        if (message == null) return null;

        // Traduzir cores hexadecimais &#RRGGBB para formato Bukkit
        return HEX_PATTERN.matcher(message).replaceAll(match -> {
            String hex = match.group().substring(2);
            StringBuilder magic = new StringBuilder("§x");
            for (char c : hex.toCharArray()) {
                magic.append("§").append(c);
            }
            return magic.toString();
        });
    }

    public String translateColors(String message) {
        if (message == null) return null;

        // Primeiro traduzir cores hexadecimais &#RRGGBB
        String hexTranslated = HEX_PATTERN.matcher(message).replaceAll(match -> {
            String hex = match.group().substring(2); // Remove &#
            StringBuilder magic = new StringBuilder("§x");
            for (char c : hex.toCharArray()) {
                magic.append("§").append(Character.toLowerCase(c));
            }
            return magic.toString();
        });

        // Depois traduzir cores normais, mas preservar códigos hex já processados
        return ChatColor.translateAlternateColorCodes('&', hexTranslated);
    }

    public void loadPlayerClan(UUID playerUuid) {
        plugin.getServer().getScheduler().runTaskAsynchronously(plugin, () -> {
            Clan clan = plugin.getDatabaseManager().getClanByPlayer(playerUuid);
            if (clan != null) {
                playerClans.put(playerUuid, clan);
            }
        });
    }

    public void unloadPlayerClan(UUID playerUuid) {
        playerClans.remove(playerUuid);
    }

    public Clan getPlayerClan(UUID playerUuid) {
        return playerClans.get(playerUuid);
    }

    public void updatePlayerClan(UUID playerUuid, Clan clan) {
        if (clan != null) {
            playerClans.put(playerUuid, clan);
        } else {
            playerClans.remove(playerUuid);
        }
    }

    public String getPlayerClanTag(UUID playerUuid) {
        Clan clan = getPlayerClan(playerUuid);
        return clan != null ? translateColors(clan.getTag()) : "";
    }

    public String getPlayerClanName(UUID playerUuid) {
        Clan clan = getPlayerClan(playerUuid);
        return clan != null ? clan.getName() : "";
    }

    public boolean isTagTooLong(String tag) {
        if (tag == null) return false;
        return getExpandedTagLength(tag) > 1000;
    }

    public int getExpandedTagLength(String tag) {
        if (tag == null) return 0;
        return translateColors(tag).length();
    }

    public String getCleanTag(String tag) {
        if (tag == null) return "";
        return ChatColor.stripColor(translateHexColors(tag));
    }

    /**
     * Obtém a tag do clã com colchetes coloridos baseado no role do jogador
     */
    public String getPlayerClanTagWithLabels(UUID playerUuid) {
        Clan clan = getPlayerClan(playerUuid);
        if (clan == null) {
            return "";
        }

        String role = getPlayerRole(playerUuid);
        String[] brackets = getBracketsForRole(role);
        String translatedTag = translateColors(clan.getTag());

        return brackets[0] + translatedTag + brackets[1];
    }

    /**
     * Obtém a tag do clã em formato small caps
     */
    public String getPlayerClanTagSmall(UUID playerUuid) {
        Clan clan = getPlayerClan(playerUuid);
        if (clan == null) {
            return "";
        }

        String translatedTag = translateColors(clan.getTag());
        return SmallTextConverter.toSmallCapsPreservingColors(translatedTag);
    }

    /**
     * Obtém a tag do clã em formato small caps com colchetes coloridos
     */
    public String getPlayerClanTagSmallWithLabels(UUID playerUuid) {
        Clan clan = getPlayerClan(playerUuid);
        if (clan == null) {
            return "";
        }

        String role = getPlayerRole(playerUuid);
        String[] brackets = getBracketsForRole(role);
        String translatedTag = translateColors(clan.getTag());
        String smallTag = SmallTextConverter.toSmallCapsPreservingColors(translatedTag);

        return brackets[0] + smallTag + brackets[1];
    }

    /**
     * Obtém o role do jogador no clã
     * Retorna apenas LEADER (para owner e admin) ou MEMBER
     */
    private String getPlayerRole(UUID playerUuid) {
        Clan clan = getPlayerClan(playerUuid);
        if (clan == null) {
            return "MEMBER";
        }

        // Se for o owner, retorna LEADER
        if (clan.getOwnerUuid().equals(playerUuid)) {
            return "LEADER";
        }

        // Para outros roles, consulta o banco
        String dbRole = plugin.getDatabaseManager().getMemberRole(clan.getId(), playerUuid);

        // Se for ADMIN, trata como LEADER para as cores
        if ("ADMIN".equalsIgnoreCase(dbRole)) {
            return "LEADER";
        }

        // Qualquer outro role é tratado como MEMBER
        return "MEMBER";
    }

    /**
     * Obtém os colchetes coloridos baseado no role
     * Apenas LEADER (líder/admin) e MEMBER (membro)
     */
    private String[] getBracketsForRole(String role) {
        String leftBracket, rightBracket;

        switch (role != null ? role.toUpperCase() : "MEMBER") {
            case "LEADER":
                leftBracket = plugin.getConfig().getString("settings.placeholder-colors.leader.left-bracket", "&4[");
                rightBracket = plugin.getConfig().getString("settings.placeholder-colors.leader.right-bracket", "&4]");
                break;
            case "MEMBER":
            default:
                leftBracket = plugin.getConfig().getString("settings.placeholder-colors.member.left-bracket", "&7[");
                rightBracket = plugin.getConfig().getString("settings.placeholder-colors.member.right-bracket", "&7]");
                break;
        }

        // Se não conseguir ler do config, usa cores padrão
        if (leftBracket == null || rightBracket == null) {
            leftBracket = plugin.getConfig().getString("settings.placeholder-colors.default.left-bracket", "&8[");
            rightBracket = plugin.getConfig().getString("settings.placeholder-colors.default.right-bracket", "&8]");
        }

        return new String[]{
                translateColors(leftBracket),
                translateColors(rightBracket)
        };
    }

    public void debugColorTranslation(String input) {
        plugin.getLogger().info("=== DEBUG CORES ===");
        plugin.getLogger().info("Input: " + input);
        plugin.getLogger().info("Hex Translated: " + translateHexColors(input));
        plugin.getLogger().info("Full Translated: " + translateColors(input));
        plugin.getLogger().info("Clean Tag: " + getCleanTag(input));
        plugin.getLogger().info("==================");
    }
}
